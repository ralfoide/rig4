package config

// The following magic lines tell go how to generate the yacc grammar.
// To do so simply invoke "go generate config" from the $GOPATH and this
// will regenerate the yy_source.go file.
// ----
//go:generate -command yacc go tool yacc
//go:generate yacc -o yy_source.go -p "source" source.y
// ----

import (
    "strings"
    "regexp"
    "fmt"
)

// Sources syntax:
// - "sources" config line contains either literal URI definitions or source references.
// - a source reference is another source config line that can also contain either URI
//   definitions or more source references.
type Sources []*Source

type ISource interface {
    Kind() string
    URI()  string
}

// A source represents an origin where to read Rig data from.
// A source has a kind (its type) and a URI. The kind represents the
// reader kind -- the actual object used to read from the source.
// The URI is an "opaque" data string passed to the reader as-is.
// Implements ISource
type Source struct{
    kind string
    uri string
}

func NewSource(kind, uri string) *Source {
    return &Source{kind, uri}
}

func (s *Source) Kind() string {
    return s.kind
}

func (s *Source) URI() string {
    return s.uri
}

// ---- Lexer ----

// Source Line syntax BNF:
// SOURCE_LINE  := ( LITERAL | REF(ID) ) ( "," SOURCE_LINE )
// ID           := [a-z]+[a-zA-Z0-9_-]+
// LITERAL      := KIND(ID) UNQUOTED | KIND QUOTED
// UNQUOTED     := ":" [^,]+
// QUOTED       := ":" \" [^"]+ \"
//
// An ID is either a "Kind" or a "Reference" depending on where it is used.
// To make it easier to write the lexer, the ":" is part of the quoted or unquoted
// URI lexer symbol but not part of the production.

// The parser expects the lexer to return 0 on EOF.  Give it a name for clarity.
const eof = 0

type keySet map[string]bool

// The parser uses the type <prefix>Lex as a lexer.  It must provide
// the methods Lex(*<prefix>SymType) int and Error(string).
type sourceLex struct {
    // Line currently being parsed by this lexer.
    line    string
    // Config key/reference currently being parsed.
    key     string
    // Error generated by this parser, if not nil.
    err     error
    // Config object used to retrieve reference strings. Can be nil.
    config  IConfigGetter
    // Sources accumulated by the parser so far.
    sources Sources
    // A set of all visited key/references so far, to prevent circular references.
    visited *keySet
}

// The parser calls this method on a parse error.
func (x *sourceLex) Error(s string) {
    x.err = fmt.Errorf("[CONFIG] '%s' %s", x.key, strings.TrimSpace(s))
}

// FindStringSubmatch substrings:
// 0 = matched line.
// 1 = token comma
// 2 = lexem ID
// 3 = lexem Quoted URI (without the leading : nor quotes)
// 4 = lexem Unquoted URI (without the leading :)
var re_tok = regexp.MustCompile("^\\s*(?:(,)|([a-z]+[a-zA-Z0-9_-]*)|:\\s*\"([^\"]+)\"|:\\s*([^\"][^,]*))")

// The parser calls this method to get each new token.
// The token IDs are generated based on the %token line in .y file
func (x *sourceLex) Lex(yylval *sourceSymType) int {
    m := re_tok.FindStringSubmatch(x.line)

    if sourceDebug >= 2 {
        fmt.Printf("[SOURCE] Lex input: %s => %#v\n", x.line, m)
    }

    if m == nil {
        return eof
    }

    x.line = x.line[len(m[0]) :]

    var s string
    if s = strings.TrimSpace(m[1]); s == "," {
        return ','
    }

    if s = strings.TrimSpace(m[2]); s != "" {
        yylval.str = s
        return ID
    }

    if s = m[3]; s != "" {
        yylval.str = s
        return URI
    }

    if s = strings.TrimSpace(m[4]); s != "" {
        yylval.str = s
        return URI
    }

    return eof
}

// ----
// Methods called by the Yacc rules

func NewSources() Sources {
    return make(Sources, 0)
}

// Parses a "sources" line and all its references.
// Typically sources comes from config.Get("sources", "") or a similarly named flag.
// IConfigGetter can be nil, in which case references are silently dropped.
func ParseSources(sources string, config IConfigGetter) (Sources, error) {
    lexer := &sourceLex{}
    lexer.key = "sources"
    lexer.line = sources
    lexer.config = config
    lexer.visited = &keySet{}

    (*lexer.visited)[lexer.key] = true

    sourceErrorVerbose = true
    if sourceDebug >= 1 {
        fmt.Printf("[SOURCE] Parse '%s'\n", lexer.key)
    }
    sourceParse(lexer)

    return lexer.sources, lexer.err
}

func addSource(x sourceLexer, kind, uri string) {
    lexer := x.(*sourceLex)
    lexer.sources = append(lexer.sources, NewSource(kind, uri))
    if sourceDebug >= 1 {
        fmt.Printf("[SOURCE] Add %s:%s for config %s\n", kind, uri, lexer.key)
    }
}

func parseReference(x sourceLexer, reference string) {
    parentLexer := x.(*sourceLex)

    if (*parentLexer.visited)[reference] {
        // Seen that reference already, ignore it.
        if sourceDebug >= 1 {
            fmt.Printf("[SOURCE] *IGNORING* Parse visited reference '%s' for config %s\n", reference, parentLexer.key)
        }
        return
    }

    config := parentLexer.config
    if config == nil {
        if sourceDebug >= 1 {
            fmt.Printf("[SOURCE] *IGNORING* Parse ref '%s' for config %s\n", reference, parentLexer.key)
        }
        return
    }

    lexer := &sourceLex{}
    lexer.key = reference
    lexer.config = config
    lexer.line = config.Get(reference, "")
    lexer.visited = parentLexer.visited

    (*lexer.visited)[lexer.key] = true

    if sourceDebug >= 1 {
        fmt.Printf("[SOURCE] Parse ref '%s'\n", lexer.key)
    }

    sourceParse(lexer)
    for _, v := range(lexer.sources) {
        parentLexer.sources = append(parentLexer.sources, v)
    }
    parentLexer.err = lexer.err
}
